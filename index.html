<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Escalonador de Processos</title>
  <link rel="stylesheet" href="css.css">
</head>

<body>

  <h1 style="text-align: center">Escalonador de Processos</h1>

  <div id="formularios" class="content">
    <form>

      <p>Escolha o tipo de processamento:</p>
      <br>

      <p>Tipo de processamento:</p>

      <input type="radio" name="tipo_processamento" value="round_robin">
      <label for="round_robin">Round Robin (RR)</label>
      <br>
      <input type="radio" name="tipo_processamento" value="sjf">
      <label for="sfj">Shrtest-Job-First (SFJ)</label>
      <br>
      <input type="radio" name="tipo_processamento" value="prioridade">
      <label for="prioridade">Por prioridade (preemptiva)</label>
    </form>

    <form>
      <br>
      <p>Adicione um processo:</p>
      <label>Nome:</label>
      <input type="text" id="nome">
      <br>
      <br>
      <label>Duração (ciclos de máquina):</label>
      <input type="text" id="duracao">
      <br>
      <br>
      <label>Prioridade:</label>
      <input type="text" id="prioridade">
      <br>
      <br>
    </form>

    <button type="button" onclick="adicionarProcesso()">Adicionar</button>
    <button type="button" onclick="processar()">Processar</button>

    <br>
  </div>


  <div id="div_processos" class="content"></div>

  <div id="resultado" class="content"></div>

  <script>
    let processos = [];

    function adicionarProcesso() {
      let processo = {
        nome: document.getElementById("nome").value,
        duracao: parseInt(document.getElementById("duracao").value)
      }

      processos.push(processo);

      atualizarDivProcessos();
    }

    function ordenarProcessos(lista) {
      processos.sort((a, b) => a.duracao - b.duracao);
    }

    function ordenarPorPrioridade(lista) {
      lista.sort((a, b) => a.prioridade - b.prioridade);
    }

    function atualizarDivProcessos() {

      let divProcessos = document.getElementById("div_processos")

      let frag = document.createDocumentFragment()

      let table = document.createElement("table")
      table.className = "processo"

      let th = document.createElement("th")
      th.innerHTML = "Processo"

      let nome = criarLinhaTabela("nome", "Nome")
      let duracao = criarLinhaTabela("duracao", "Duração")

      table.appendChild(th)
      table.appendChild(nome)
      table.appendChild(duracao)

      frag.appendChild(table)
      divProcessos.appendChild(frag)

    }

    function criarLinhaTabela(campo, nome) {
      frag = document.createDocumentFragment()

      tr = document.createElement("tr")
      td = document.createElement("td")

      td.innerHTML = `${nome}: ${document.getElementById(campo).value}`

      tr.appendChild(td)
      frag.appendChild(tr)

      return frag
    }

    function processar() {
      const quantum = 2;
      let tipoProcessamento = document.querySelector('input[name="tipo_processamento"]:checked').value;
      let resultado = document.getElementById("resultado");

      if (tipoProcessamento === "round_robin") {
        resultado.innerHTML = roundRobin();
      } else if (tipoProcessamento === "sjf") {
        resultado.innerHTML = shortestJobFirst();
      } else if (tipoProcessamento === "prioridade") {
        resultado.innerHTML = prioridadePreemptiva();
      }

      // Cada processo recebe uma quantidade fixa de tempo de CPU (quantum) e, se não for concluído nesse período, é colocado no final da fila para aguardar sua próxima vez
      function roundRobin() {
        let tempo = 0;
        let log = '';
        // Cria uma cópia da lista de processos
        let fila = [...processos];

        // Loop que continua até que todos os processos sejam concluídos
        while (fila.length > 0) {
          //Remove o primeiro processo da fila
          let processo = fila.shift();
          if (processo.duracao > quantum) {
            log += `${tempo} - ${processo.nome} (executa por ${quantum} ciclos)\n`;
            tempo += quantum;
            processo.duracao -= quantum;
            fila.push(processo); // Adiciona de volta ao final da fila
          } else {
            log += `${tempo} - ${processo.nome} (executa por ${processo.duracao} ciclos)\n`;
            tempo += processo.duracao;
            processo.duracao = 0;
          }
        }
        return log.replace(/\n/g, '<br>');
      }

      function shortestJobFirst() {
        let tempo = 0;
        let log = '';
        let fila = [...processos];

        // Ordena os processos pela duração, do menor para o maior
        ordenarProcessos(fila);

        while (fila.length > 0) {
          let processo = fila.shift();
          log += `${tempo} - ${processo.nome} (executa por ${processo.duracao} ciclos)\n`;
          tempo += processo.duracao;
        }

        return log.replace(/\n/g, '<br>');
      }

      // Cada processo terá uma prioridade associada e que o processo de maior prioridade deve ser executado primeiro. 
      // Se um novo processo de maior prioridade chega enquanto um processo está sendo executado, 
      // o processo atual deve ser preemptado e o novo processo deve começar a ser executado.

      function prioridadePreemptiva() {
        let tempo = 0;
        let log = '';
        let fila = [...processos];

        // Ordena os processos pela prioridade, do menor para o maior (maior prioridade)
        ordenarPorPrioridade(fila);

        while (fila.length > 0) {
          let processo = fila.shift();
          log += `${tempo} - ${processo.nome} (executa por ${processo.duracao} ciclos)\n`;
          tempo += processo.duracao;

          // Reordenar a fila pela prioridade após cada execução para simular preempção
          ordenarPorPrioridade(fila);
        }

        return log.replace(/\n/g, '<br>');
      }

    }

  </script>
</body>
<br>
<div>
  <br>
  <br>
  <br>
  <footer class="rodape">Desenvolvido por: Alani Rigotti de Oliveira, Luana Schmidt e Mateus Maas.</footer>

</div>

</html>